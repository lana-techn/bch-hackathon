{
  "contractName": "BondingCurve",
  "constructorInputs": [
    {
      "name": "tokenCategory",
      "type": "bytes32"
    },
    {
      "name": "feeAddress",
      "type": "bytes20"
    },
    {
      "name": "slope",
      "type": "int"
    },
    {
      "name": "graduationTarget",
      "type": "int"
    },
    {
      "name": "curveSupply",
      "type": "int"
    }
  ],
  "abi": [
    {
      "name": "buy",
      "inputs": [
        {
          "name": "tokensToBuy",
          "type": "int"
        }
      ]
    },
    {
      "name": "sell",
      "inputs": [
        {
          "name": "tokensToSell",
          "type": "int"
        }
      ]
    },
    {
      "name": "graduate",
      "inputs": [
        {
          "name": "dexPoolScriptHash",
          "type": "bytes32"
        }
      ]
    }
  ],
  "bytecode": "OP_5 OP_PICK OP_0 OP_NUMEQUAL OP_IF OP_6 OP_PICK OP_0 OP_GREATERTHAN OP_VERIFY OP_INPUTINDEX OP_UTXOTOKENCOMMITMENT OP_BIN2NUM OP_DUP OP_8 OP_PICK OP_ADD OP_DUP OP_7 OP_ROLL OP_LESSTHANOREQUAL OP_VERIFY OP_DUP OP_DUP OP_MUL OP_2 OP_PICK OP_3 OP_ROLL OP_MUL OP_5 OP_ROLL OP_ROT OP_ROT OP_SUB OP_MUL 00c2eb0b OP_DIV OP_DUP 64 OP_DIV OP_DUP 2202 OP_GREATERTHANOREQUAL OP_VERIFY OP_INPUTINDEX OP_UTXOBYTECODE OP_0 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_INPUTINDEX OP_UTXOTOKENCATEGORY OP_0 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCOMMITMENT OP_3 OP_ROLL OP_8 OP_NUM2BIN OP_EQUALVERIFY OP_INPUTINDEX OP_UTXOTOKENAMOUNT OP_0 OP_OUTPUTTOKENAMOUNT OP_SWAP OP_8 OP_PICK OP_SUB OP_NUMEQUALVERIFY OP_INPUTINDEX OP_UTXOVALUE OP_0 OP_OUTPUTVALUE OP_SWAP OP_3 OP_ROLL OP_ADD OP_GREATERTHANOREQUAL OP_VERIFY OP_1 OP_OUTPUTTOKENAMOUNT OP_6 OP_ROLL OP_NUMEQUALVERIFY OP_1 OP_OUTPUTTOKENCATEGORY OP_ROT OP_EQUALVERIFY OP_2 OP_OUTPUTVALUE OP_LESSTHANOREQUAL OP_VERIFY OP_2 OP_OUTPUTBYTECODE 76a914 OP_ROT OP_CAT 88ac OP_CAT OP_EQUAL OP_NIP OP_NIP OP_ELSE OP_5 OP_PICK OP_1 OP_NUMEQUAL OP_IF OP_6 OP_PICK OP_0 OP_GREATERTHAN OP_VERIFY OP_INPUTINDEX OP_UTXOTOKENCOMMITMENT OP_BIN2NUM OP_7 OP_PICK OP_OVER OP_LESSTHANOREQUAL OP_VERIFY OP_DUP OP_8 OP_PICK OP_SUB OP_OVER OP_ROT OP_MUL OP_OVER OP_2 OP_PICK OP_MUL OP_5 OP_ROLL OP_ROT OP_ROT OP_SUB OP_MUL 00c2eb0b OP_DIV OP_DUP 64 OP_DIV OP_2DUP OP_SUB OP_OVER 2202 OP_GREATERTHANOREQUAL OP_VERIFY OP_INPUTINDEX OP_UTXOBYTECODE OP_0 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_INPUTINDEX OP_UTXOTOKENCATEGORY OP_0 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCOMMITMENT OP_4 OP_ROLL OP_8 OP_NUM2BIN OP_EQUALVERIFY OP_INPUTINDEX OP_UTXOTOKENAMOUNT OP_0 OP_OUTPUTTOKENAMOUNT OP_SWAP OP_10 OP_ROLL OP_ADD OP_NUMEQUALVERIFY OP_INPUTINDEX OP_UTXOVALUE OP_0 OP_OUTPUTVALUE OP_SWAP OP_4 OP_ROLL OP_SUB OP_GREATERTHANOREQUAL OP_VERIFY OP_1 OP_OUTPUTVALUE OP_LESSTHANOREQUAL OP_VERIFY OP_2 OP_OUTPUTVALUE OP_LESSTHANOREQUAL OP_VERIFY OP_2 OP_OUTPUTBYTECODE 76a914 OP_3 OP_ROLL OP_CAT 88ac OP_CAT OP_EQUALVERIFY OP_2DROP OP_2DROP OP_1 OP_ELSE OP_5 OP_ROLL OP_2 OP_NUMEQUALVERIFY OP_INPUTINDEX OP_UTXOVALUE OP_DUP OP_5 OP_ROLL OP_GREATERTHANOREQUAL OP_VERIFY aa20 OP_6 OP_ROLL OP_CAT 87 OP_CAT OP_OVER 64 OP_DIV OP_0 OP_OUTPUTVALUE OP_3 OP_ROLL OP_2 OP_PICK OP_SUB OP_GREATERTHANOREQUAL OP_VERIFY OP_0 OP_OUTPUTBYTECODE OP_ROT OP_EQUALVERIFY OP_INPUTINDEX OP_UTXOTOKENAMOUNT OP_0 OP_OUTPUTTOKENAMOUNT OP_LESSTHANOREQUAL OP_VERIFY OP_0 OP_OUTPUTTOKENCATEGORY OP_ROT OP_EQUALVERIFY OP_1 OP_OUTPUTVALUE OP_LESSTHANOREQUAL OP_VERIFY OP_1 OP_OUTPUTBYTECODE 76a914 OP_ROT OP_CAT 88ac OP_CAT OP_EQUAL OP_NIP OP_NIP OP_ENDIF OP_ENDIF",
  "source": "// ============================================================================\n// IiteBCH - Bonding Curve Covenant Contract\n// ============================================================================\n//\n// This covenant contract implements a linear bonding curve for CashTokens.\n//\n// Architecture:\n//   - The contract UTXO holds BCH (reserve) + unsold fungible tokens\n//   - A mutable NFT commitment stores the current state (supply sold)\n//   - Price formula: P = SLOPE * supplySold (linear curve)\n//   - Cost to buy tokens from S to S+dS: SLOPE/2 * ((S+dS)^2 - S^2)\n//   - Since CashScript has no sqrt(), we verify the cost constraint instead\n//     of computing exact token output\n//\n// State (stored in NFT commitment, 8 bytes):\n//   - bytes8: currentSupplySold (int, scaled by 1)\n//\n// Parameters (constructor):\n//   - tokenCategory: bytes32 - the CashToken category ID (unreversed)\n//   - feeAddress: bytes20 - P2PKH hash of the fee collection address\n//   - slope: int - bonding curve slope (scaled by PRECISION)\n//   - graduationTarget: int - BCH target in satoshis (e.g., 40 * 1e8)\n//   - curveSupply: int - max tokens available on curve (e.g., 800_000_000)\n//\n// ============================================================================\n\npragma cashscript ^0.12.0;\n\ncontract BondingCurve(\n    bytes32 tokenCategory,\n    bytes20 feeAddress,\n    int slope,\n    int graduationTarget,\n    int curveSupply\n) {\n    // ========================================================================\n    // BUY: User sends BCH, receives fungible tokens from the curve\n    // ========================================================================\n    //\n    // Transaction structure:\n    //   Input 0: This contract UTXO (BCH + tokens + mutable NFT)\n    //   Input 1: User's BCH input(s) - handled externally\n    //   Output 0: Updated contract UTXO (more BCH, fewer tokens, updated state)\n    //   Output 1: User receives purchased tokens\n    //   Output 2: Fee output to feeAddress\n    //   (Output 3+: optional change back to user)\n    //\n    function buy(int tokensToBuy) {\n        // --- Validate tokensToBuy ---\n        require(tokensToBuy > 0);\n\n        // --- Read current state from NFT commitment ---\n        int currentSupplySold = int(tx.inputs[this.activeInputIndex].nftCommitment);\n\n        // --- Calculate new supply after buy ---\n        int newSupplySold = currentSupplySold + tokensToBuy;\n        require(newSupplySold <= curveSupply);\n\n        // --- Calculate cost using linear bonding curve ---\n        // Cost = (slope / 2) * (newSupply^2 - currentSupply^2)\n        // Since we use integer math and slope is pre-scaled by PRECISION (1e8):\n        // cost = slope * (newSupply^2 - currentSupply^2) / (2 * PRECISION)\n        int newSquared = newSupplySold * newSupplySold;\n        int oldSquared = currentSupplySold * currentSupplySold;\n        int rawCost = slope * (newSquared - oldSquared);\n        int cost = rawCost / 200000000; // divide by 2 * PRECISION (2 * 1e8)\n\n        // --- Calculate fee (1%) ---\n        int fee = cost / 100;\n        require(fee >= 546); // minimum dust limit for fee output\n\n        // --- Enforce self-preservation (covenant) ---\n        // Output 0 must go back to this contract\n        bytes contractBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n        require(tx.outputs[0].lockingBytecode == contractBytecode);\n\n        // --- Enforce token category persists (mutable NFT + fungible tokens) ---\n        // The contract input has mutable NFT capability (0x01 suffix)\n        bytes inputCategory = tx.inputs[this.activeInputIndex].tokenCategory;\n        require(tx.outputs[0].tokenCategory == inputCategory);\n\n        // --- Enforce updated NFT commitment (state update) ---\n        require(tx.outputs[0].nftCommitment == bytes8(newSupplySold));\n\n        // --- Enforce token balance: contract keeps remaining tokens ---\n        int inputTokens = tx.inputs[this.activeInputIndex].tokenAmount;\n        require(tx.outputs[0].tokenAmount == inputTokens - tokensToBuy);\n\n        // --- Enforce BCH balance: contract receives the cost ---\n        int inputValue = tx.inputs[this.activeInputIndex].value;\n        require(tx.outputs[0].value >= inputValue + cost);\n\n        // --- Enforce user receives purchased tokens (Output 1) ---\n        // We verify the token amount, but allow any destination address\n        require(tx.outputs[1].tokenAmount == tokensToBuy);\n        require(tx.outputs[1].tokenCategory == tokenCategory);\n\n        // --- Enforce fee output (Output 2) ---\n        require(tx.outputs[2].value >= fee);\n        require(tx.outputs[2].lockingBytecode == new LockingBytecodeP2PKH(feeAddress));\n    }\n\n    // ========================================================================\n    // SELL: User returns tokens, receives BCH from the curve reserve\n    // ========================================================================\n    //\n    // Transaction structure:\n    //   Input 0: This contract UTXO (BCH + tokens + mutable NFT)\n    //   Input 1: User's token UTXO (tokens to sell)\n    //   Output 0: Updated contract UTXO (less BCH, more tokens, updated state)\n    //   Output 1: User receives BCH proceeds\n    //   Output 2: Fee output to feeAddress\n    //\n    function sell(int tokensToSell) {\n        // --- Validate ---\n        require(tokensToSell > 0);\n\n        // --- Read current state ---\n        int currentSupplySold = int(tx.inputs[this.activeInputIndex].nftCommitment);\n        require(tokensToSell <= currentSupplySold);\n\n        // --- Calculate new supply after sell ---\n        int newSupplySold = currentSupplySold - tokensToSell;\n\n        // --- Calculate return using linear bonding curve ---\n        // Return = (slope / 2) * (currentSupply^2 - newSupply^2)\n        int oldSquared = currentSupplySold * currentSupplySold;\n        int newSquared = newSupplySold * newSupplySold;\n        int rawReturn = slope * (oldSquared - newSquared);\n        int grossReturn = rawReturn / 200000000; // divide by 2 * PRECISION\n\n        // --- Calculate fee (1%) ---\n        int fee = grossReturn / 100;\n        int netReturn = grossReturn - fee;\n        require(fee >= 546); // minimum dust\n\n        // --- Enforce self-preservation ---\n        bytes contractBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n        require(tx.outputs[0].lockingBytecode == contractBytecode);\n\n        // --- Enforce token category persists ---\n        bytes inputCategory = tx.inputs[this.activeInputIndex].tokenCategory;\n        require(tx.outputs[0].tokenCategory == inputCategory);\n\n        // --- Enforce updated state ---\n        require(tx.outputs[0].nftCommitment == bytes8(newSupplySold));\n\n        // --- Enforce token balance: contract gets back the sold tokens ---\n        int inputTokens = tx.inputs[this.activeInputIndex].tokenAmount;\n        require(tx.outputs[0].tokenAmount == inputTokens + tokensToSell);\n\n        // --- Enforce BCH balance: contract sends out the return ---\n        int inputValue = tx.inputs[this.activeInputIndex].value;\n        require(tx.outputs[0].value >= inputValue - grossReturn);\n\n        // --- Enforce user receives BCH (Output 1) ---\n        require(tx.outputs[1].value >= netReturn);\n\n        // --- Enforce fee output (Output 2) ---\n        require(tx.outputs[2].value >= fee);\n        require(tx.outputs[2].lockingBytecode == new LockingBytecodeP2PKH(feeAddress));\n    }\n\n    // ========================================================================\n    // GRADUATE: Migrate liquidity to DEX when graduation target is met\n    // ========================================================================\n    //\n    // When the BCH reserve reaches the graduation target, anyone can trigger\n    // migration. The BCH + remaining tokens are sent to a DEX pool.\n    //\n    // Transaction structure:\n    //   Input 0: This contract UTXO\n    //   Output 0: DEX pool receives BCH + remaining tokens\n    //   Output 1: Fee output\n    //\n    function graduate(bytes32 dexPoolScriptHash) {\n        // --- Verify graduation threshold met ---\n        int reserveBalance = tx.inputs[this.activeInputIndex].value;\n        require(reserveBalance >= graduationTarget);\n\n        // --- All BCH + tokens go to the DEX pool ---\n        // DEX pool script hash provided as argument (verified off-chain)\n        bytes35 dexLockingBytecode = new LockingBytecodeP2SH32(dexPoolScriptHash);\n\n        // Send BCH to DEX (minus fee)\n        int fee = reserveBalance / 100; // 1% graduation fee\n        require(tx.outputs[0].value >= reserveBalance - fee);\n        require(tx.outputs[0].lockingBytecode == dexLockingBytecode);\n\n        // Send remaining tokens to DEX\n        int remainingTokens = tx.inputs[this.activeInputIndex].tokenAmount;\n        require(tx.outputs[0].tokenAmount >= remainingTokens);\n        require(tx.outputs[0].tokenCategory == tokenCategory);\n\n        // Fee output\n        require(tx.outputs[1].value >= fee);\n        require(tx.outputs[1].lockingBytecode == new LockingBytecodeP2PKH(feeAddress));\n    }\n}\n",
  "debug": {
    "bytecode": "5579009c63567900a069c0cf817658799376577aa1697676955279537a95557a7b7b94950400c2eb0b967601649676022202a269c0c700cd88c0ce00d18800d2537a588088c0d000d37c5879949dc0c600cc7c537a93a26951d3567a9d51d17b8852cca16952cd0376a9147b7e0288ac7e877777675579519c63567900a069c0cf81577978a16976587994787b9578527995557a7b7b94950400c2eb0b96760164966e9478022202a269c0c700cd88c0ce00d18800d2547a588088c0d000d37c5a7a939dc0c600cc7c547a94a26951cca16952cca16952cd0376a914537a7e0288ac7e886d6d5167557a529dc0c676557aa26902aa20567a7e01877e7801649600cc537a527994a26900cd7b88c0d000d3a16900d17b8851cca16951cd0376a9147b7e0288ac7e8777776868",
    "sourceMap": "48:4:101:5;;;;;50:16:50:27;;:30::31;:16:::1;:8::33;53:46:53:67:0;:36::82:1;:32::83;56:28:56:45:0;:48::59;;:28:::1;57:16:57:29:0;:33::44;;:16:::1;:8::46;63:25:63:54:0;;::::1;64::64:42:0;;:45::62;;:25:::1;65:22:65:27:0;;:31::41;:44::54;:31:::1;:22::55;66:29:66:38:0;:19:::1;69:18:69:22:0;:25::28;:18:::1;70:16:70:19:0;:23::26;:16:::1;:8::28;74:43:74:64:0;:33::81:1;75:27:75:28:0;:16::45:1;:8::67;79:40:79:61:0;:30::76:1;80:27:80:28:0;:16::43:1;:8::62;83:27:83:28:0;:16::43:1;:54::67:0;;:47::68:1;;:8::70;86:36:86:57:0;:26::70:1;87:27:87:28:0;:16::41:1;:45::56:0;:59::70;;:45:::1;:8::72;90:35:90:56:0;:25::63:1;91:27:91:28:0;:16::35:1;:39::49:0;:52::56;;:39:::1;:16;:8::58;95:27:95:28:0;:16::41:1;:45::56:0;;:8::58:1;96:27:96:28:0;:16::43:1;:47::60:0;:8::62:1;99:27:99:28:0;:16::35:1;:::42;:8::44;100:27:100:28:0;:16::45:1;:49::85:0;:74::84;:49::85:1;;;:8::87;48:4:101:5;;;114::162::0;;;;;116:16:116:28;;:31::32;:16:::1;:8::34;119:46:119:67:0;:36::82:1;:32::83;120:16:120:28:0;;:32::49;:16:::1;:8::51;123:28:123:45:0;:48::60;;:28:::1;127:25:127:42:0;:45::62;:25:::1;128::128:38:0;:41::54;;:25:::1;129:24:129:29:0;;:33::43;:46::56;:33:::1;:24::57;130:38:130:47:0;:26:::1;133:18:133:29:0;:32::35;:18:::1;134:24:134:41:0;::::1;135:16:135:19:0;:23::26;:16:::1;:8::28;138:43:138:64:0;:33::81:1;139:27:139:28:0;:16::45:1;:8::67;142:40:142:61:0;:30::76:1;143:27:143:28:0;:16::43:1;:8::62;146:27:146:28:0;:16::43:1;:54::67:0;;:47::68:1;;:8::70;149:36:149:57:0;:26::70:1;150:27:150:28:0;:16::41:1;:45::56:0;:59::71;;:45:::1;:8::73;153:35:153:56:0;:25::63:1;154:27:154:28:0;:16::35:1;:39::49:0;:52::63;;:39:::1;:16;:8::65;157:27:157:28:0;:16::35:1;:::48;:8::50;160:27:160:28:0;:16::35:1;:::42;:8::44;161:27:161:28:0;:16::45:1;:49::85:0;:74::84;;:49::85:1;;;:8::87;114:4:162:5;;;;176::198::0;;;;178:39:178:60;:29::67:1;179:16:179:30:0;:34::50;;:16:::1;:8::52;183:37:183:81:0;:63::80;;:37::81:1;;;186:18:186:32:0;:35::38;:18:::1;187:27:187:28:0;:16::35:1;:39::53:0;;:56::59;;:39:::1;:16;:8::61;188:27:188:28:0;:16::45:1;:49::67:0;:8::69:1;191:40:191:61:0;:30::74:1;192:27:192:28:0;:16::41:1;:::60;:8::62;193:27:193:28:0;:16::43:1;:47::60:0;:8::62:1;196:27:196:28:0;:16::35:1;:::42;:8::44;197:27:197:28:0;:16::45:1;:49::85:0;:74::84;:49::85:1;;;:8::87;176:4:198:5;;29:0:199:1;",
    "logs": [],
    "requires": [
      {
        "ip": 14,
        "line": 50
      },
      {
        "ip": 26,
        "line": 57
      },
      {
        "ip": 49,
        "line": 70
      },
      {
        "ip": 54,
        "line": 75
      },
      {
        "ip": 59,
        "line": 80
      },
      {
        "ip": 66,
        "line": 83
      },
      {
        "ip": 75,
        "line": 87
      },
      {
        "ip": 85,
        "line": 91
      },
      {
        "ip": 90,
        "line": 95
      },
      {
        "ip": 94,
        "line": 96
      },
      {
        "ip": 98,
        "line": 99
      },
      {
        "ip": 107,
        "line": 100
      },
      {
        "ip": 119,
        "line": 116
      },
      {
        "ip": 127,
        "line": 120
      },
      {
        "ip": 155,
        "line": 135
      },
      {
        "ip": 160,
        "line": 139
      },
      {
        "ip": 165,
        "line": 143
      },
      {
        "ip": 172,
        "line": 146
      },
      {
        "ip": 181,
        "line": 150
      },
      {
        "ip": 191,
        "line": 154
      },
      {
        "ip": 195,
        "line": 157
      },
      {
        "ip": 199,
        "line": 160
      },
      {
        "ip": 208,
        "line": 161
      },
      {
        "ip": 223,
        "line": 179
      },
      {
        "ip": 241,
        "line": 187
      },
      {
        "ip": 245,
        "line": 188
      },
      {
        "ip": 251,
        "line": 192
      },
      {
        "ip": 255,
        "line": 193
      },
      {
        "ip": 259,
        "line": 196
      },
      {
        "ip": 268,
        "line": 197
      }
    ]
  },
  "compiler": {
    "name": "cashc",
    "version": "0.12.1"
  },
  "updatedAt": "2026-02-09T07:22:21.167Z"
}